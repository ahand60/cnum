[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cálculo Numérico Modular",
    "section": "",
    "text": "1 Zeros de Funções\nNeste capítulo trataremos de métodos para resolver equações. E como toda equação pode ser escrita por\n\\[f(x)=0\\]\neste assunto também é dito Zeros de Funções. Trataremos aqui de métodos que resolve equações que satisfazem algumas poucas condições. Mas essa restrição não invalida o esforço do estudo pois é grande a variedade de equações que podem ser resolvidos pelos métodos apresentados. Começamos definindo o zero de uma função.\nAlguns exemplos de zeros de funções podemos ver na tabela abaixo.\nA função quadrática \\(f_{1}(x)\\) pode ser resolvida pela fórmula de Bháskara \\[x=\\frac{-b\\pm \\sqrt{b^2-4ac}}{2a}\\]\nque fornece a resposta diretamente. A função cúbica \\(f_{2}(x)\\) pode ser resolvida pela fórmula de Tartáglia, mas as demais funções dessa lista não possuem fórmula alguma. Então como calcular os raízes delas ? Até funções polinômiais de ordem maior que 4 não há fórmulas de resolução. Dessa forma como se podemos resolver uma equação como \\[x^5+2x^2-x=0  ?\\]\nNeste capítulo, vamos aprender a resolver essa e outras equações que não possuem fórmulas prontas de resolução.\nOs métodos que aprenderemos aqui são chamados de Métodos Iterativos. Isso por conta das iterações ou rodadas que fazemos para melhorar (ou refinar) cada vez mais a raíz da equação. Raíz de uma equação é a solução do problema em questão.\nDiferentemente do Método Direto ou Analítico que usa uma fórmula como a de Bháskara para resolver uma equação de 2º grau. Essa fórmula nos fornece as raízes diretamente.\nMétodos Iterativos são úteis para resolver equações que não possuem fórmulas de resolução. E elas são, na verdade, a maioria. Para determinar a raiz da equação pelo método iterativo existem algumas etapas que devemos percorrer, a saber :\nAs quatro primeiras etapas normalmente são fornecidas no enunciado da questão, embora isso não seja uma regra. Já a quinta etapa é a parte que o aluno precisa fazer. É nesta etapa que o aluno será avaliado.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Zeros de Funções</span>"
    ]
  },
  {
    "objectID": "index.html#precisão",
    "href": "index.html#precisão",
    "title": "Cálculo Numérico Modular",
    "section": "1.1 Precisão",
    "text": "1.1 Precisão\nA precisão da conta é para definir a proximidade em relação à raiz. Suponhamos que a raiz seja \\(r=3,135104\\). Consideremos os seguintes números\n\\[\\left\\{\\begin{matrix}\na_1 = 3,135199\\\\\na_2 = 3,135098\n\\end{matrix}\\right.\\]\ncujas diferenças em módulo em relação a r são, respectivamente\n\\[\\begin{array}{c}|a_{1}-r|=0,000095&lt;10^{-4}\\\\|a_{2}-r|=0,000006&lt;10^{-5}\\end{array}.\\]\nDizemos que a precisão de \\(a_{1}\\) é de \\(\\varepsilon=10^{-4}\\) e a de \\(a_{2}\\) é de \\(\\varepsilon=10^{-5}\\), portanto \\(a_{2}\\) é mais próxima à raiz e por isso é um resultado melhor. Entretanto, não confunda a precisão com o número de casas decimais corretas. Observe que \\(a_{1}\\) tem as primeiras 4 casas decimais corretas ao passo que \\(a_{2}\\) apenas 3, embora seja um resultado melhor\n\\[\\begin{array}{c}a_{1}=3,\\underline{1351}99\\\\a_{2}=3,\\underline{135}098\\end{array}.\\]\nOutra maneira de se referir à precisão é dizer que \\(a_{1}\\) tem precisão de 4 casas decimais e \\(a_{2}\\) tem a precisão de 5 casas decimais. Isso tem a ver com o número de zeros na diferença para o valor correto e não com o número de decimais corretas. Mas há casos em que o enunciado pede justamente isso: decimais corretas até a \\(n\\)-ésima casa. Por isso deve-se sempre prestar atenção no enunciado do problema! Quando se pede isso, o exemplo acima nos dá uma ideia do que fazer : aumentar a precisão em algumas casas decimais. Nesse exemplo vimos que \\(a_{2}\\) tem a precisão de 5 casas, pois, \\(\\varepsilon=10^{-5}\\), mas acerta apenas as 3 primeiras casas decimais. Se o enunciado pedir 4 corretas, temos que trabalhar com uma precisão maior, talvez \\(\\varepsilon=10^{-6}\\). Mas, dependendo do dígito da \\(n\\)-ésima casa, muitas vezes a precisão de \\(n\\) casas já é suficiente. Veja no exemplo acima onde \\(a_{1}\\) tem precisão de 4 casas e acertando as 4 decimais iniciais. Em geral, uma precisão de \\(n+1\\) casas já serve para acertar as \\(n\\) decimais iniciais. Mas isso nem sempre acontece. Quando há a presença de zeros no valor exato, por exemplo, pode dar problemas. Vejamos um exemplo. Suponhamos que o valor correto seja \\[r=3,121002.\\] Com a precisão de 5 casas e obtemos os seguintes resultados \\[\\begin{array}{c}a_{1}=3,\\underline{12}0993\\\\a_{2}=3,\\underline{1210}10\\\\a_{3}=3,\\underline{12100}9\\end{array}\\] Verifique que todos têm a mesma precisão de \\(\\varepsilon=10^{-5}\\) mas os números \\(a_{1},a_{2},a_{3}\\) acertam, respectivamente, duas, quatro e cinco casas decimais. Uma observação a fazer aqui é a seguinte: quando se pede n decimais corretas, não significa qualquer decimais mas sempre as primeiras decimais a partir da vírgula.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Zeros de Funções</span>"
    ]
  },
  {
    "objectID": "index.html#chute-inicial",
    "href": "index.html#chute-inicial",
    "title": "Cálculo Numérico Modular",
    "section": "1.2 Chute Inicial",
    "text": "1.2 Chute Inicial\nCaso o valor inicial não seja fornecido, você mesmo deve fazer esse chute. Depois, é só rodar o programa e veja se ele converge para algum ponto fixo. Esse ponto fixo será a raiz do problema. Um bom chute inicial faz o processo convergir para algum lugar. Esse lugar que falamos é um valor cujo processo modifica muito pouco os seus dígitos, talvez só na décima primeira casa decimal. Por isso o chamamos de ponto fixo.\nMas, como podemos saber se o chute inicial que fizemos foi bom ou não ? Essa é uma boa pergunta. Normalmente se você começar por um ponto mais ou menos próximo à raiz, será um bom chute. Mas pode acontecer que o chute não seja tão perto da raiz, mesmo assim converge para um ponto fixo. Então não se preocupe muito com isso. Basta você rodar o programa e ver se converge. Se não convergir, tente outro chute e recomece o processo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Zeros de Funções</span>"
    ]
  },
  {
    "objectID": "index.html#método-de-refinamento",
    "href": "index.html#método-de-refinamento",
    "title": "Cálculo Numérico Modular",
    "section": "1.3 Método de Refinamento",
    "text": "1.3 Método de Refinamento\nA segunda etapa é escolher um método de refinamento. Esse método por vezes também é uma exigência do professor/examinador. Mas quando não é fornecido ou não é exigido, você pode escolher qualquer um dos métodos ensinados e aprendidos.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Zeros de Funções</span>"
    ]
  },
  {
    "objectID": "index.html#critérios-de-parada",
    "href": "index.html#critérios-de-parada",
    "title": "Cálculo Numérico Modular",
    "section": "1.4 Critérios de Parada",
    "text": "1.4 Critérios de Parada\nNeste texto vamos usar dois critérios de parada, um para cada variável. Por que isso ? Lembramos que estamos trabalhando com duas variáveis, \\(x\\) e \\(y\\), a segunda dependente da primeira, ou seja \\(y=f(x)\\). Dizemos que \\(y\\) é a imagem de \\(x\\) e que \\(x\\) é abscissa de \\(y\\). Também se diz de \\(y\\) como ordenada de \\(x\\) e \\(x\\) como pré-imagem de \\(y\\). Lembrando que, uma raiz de \\(f\\) é um valor \\(x=r\\) tal que \\(y=f(r)=0\\). Assim queremos achar um valor da variável \\(x\\) determinado pelo valor 0 da outra variável: \\(y\\). Quem pode-me garantir que um valor próximo à raiz tem imagem próxima de zero ? Veja por exemplo a função\n\\[f(x)=5000x^2-300\\]\ncuja raíz positiva é \\(r=0,24495\\). O valor \\(a=0,244\\) é bastante próxima à raiz com precisão de \\(0,00095&lt;\\varepsilon=10^{-3}\\) mas a imagem dele é longe de zero, pois \\(f(a)=-2,32\\) . Na verdade, qualquer função cujo gráfico é quase vertical na raiz vai dar esse problema.\n\n\n\nGráfico da função \\(f(x)\\)\n\n\nDessa forma, vamos adotar dois critérios de parada. Para a variável x devemos garantir que\n\\[|x-r|&lt;\\varepsilon\\]\ne para a variável \\(y=f(x)\\) vamos adotar o critério\n\\[|f(x)|&lt;\\varepsilon\\] e usaremos a mesma precisão para ambos os critérios. Mas observe que há um grande problema no primeiro critério de parada, pois não sabemos o valor exato de \\(r\\). Justamente esse valor de \\(r\\) que estamos procurando. Portanto precisamos trocá-lo por outro critério tangível. Há duas formas de fazer isso. O primeiro deles é calcular a melhora dos passos da sequência de iterações (também chamado de erro absoluto). \\[|x_{i}-x_{i+1}|&lt;\\varepsilon\\]\nA segunda maneira é calcular a “porcentagem” de melhora desses passos ou mais precisamente a taxa de melhora dos passos (também chamado de erro relativo), dada por\n\\[\\left|\\frac{x_{i}-x_{i+1}}{x_{i+1}}\\right|&lt;\\varepsilon\\]\nEssa segunda fórmula é mais sensível a erros, pois em nenhum momento a sequência de iterações pode atingir o valor zero. Pois senão estaríamos dividindo por zero. Aliás, essa também é a razão porque se coloca \\(x_{i+1}\\) no denominador, e não \\(x_{i}\\), pois na maioria das vezes o valor inicial que adotamos é o zero. Se assim for, o processo já começa com problema.\nDiante do exposto vamos adotar o critério de melhora dos passos para garantir a aproximação da abscissa x à raiz em questão.\nUm terceiro critério de parada seria o número máximo de iterações. Existem casos em que o processo de refinamento não converge para nenhum lugar. Nesses casos nenhum dos critérios anteriores serão satisfeitos, mas o processo precisa parar de alguma forma. Para isso pode-se adotar o número máxima de iterações como outro critério de parada. Isso é necessário quando o processo é implementado em um sistema automático, como em computador. Quando o processo é executado manualmente o número máximo de iterações não deve ser muito alto, talvez no máximo uma dúzia de iterações ou próximo disso. Hoje em dia com o recurso do computador esse número máximo pode ser um milhão ou mais. Mas neste caso o problema passa a ser o esforço humano. Acredito que ninguém vai fazer um milhão de rodadas a não ser que saiba automatizar esse processo. Para isso você deve saber e usar uma linguagem de programação, o que complica mais o aprendizado. Mesmo assim, acredito que se um processo atingir um milhão de rodadas … muito provavelmente ele não vai convergir a lugar nenhum. Então porque raios devemos executar tantas rodadas ? Como disse antes, se você rodar e depois de umas cinquenta rodadas, ou até menos, ele não atinge um ponto fixo .. você deve começar a desconfiar que o processo não converge. Neste caso, descarte tudo e comece novamente com outro chute inicial. Simples assim. Por este motivo também que não vamos adotar esse terceiro critério de parada.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Zeros de Funções</span>"
    ]
  },
  {
    "objectID": "index.html#execução-do-processo",
    "href": "index.html#execução-do-processo",
    "title": "Cálculo Numérico Modular",
    "section": "1.5 Execução do Processo",
    "text": "1.5 Execução do Processo\nA fase de execução do processo é aquela que o aluno precisa mostrar na prova/exame. Neste texto a execução do processo não será feita manualmente e nem tampouco automaticamente. Vamos implementar sim em um computador mas o processo não será executado automaticamente, mas sim iteração por iteração. Por isso mesmo não vamos precisar impor o número máximo de iterações como um critério de parada. Vamos avaliar a continuidade do processo ou não a cada nova iteração.\nA execução do processo será feita no computador usando softwares específicos. No caso de zeros de funções, assunto deste capítulo, vamos usar uma planilha eletrônica tais como Excel, Calc, Google Planilhas ou Geogebra. Cada iteração corresponde a uma linha da planilha.\nNo capítulo 2, quando falamos de ajuste de curvas, vamos usar o Matlab, Scilab, Octave ou Geogebra. Mas nesse capítulo o processo não será iterativo, senão analítico. Uma única iteração basta para resolver o problema.\nNo capítulo 3, falamos de Interpolação Polinomial. Nele vamos usar o software Geogebra e o processo também não será iterativo.\nNo capítulo 4. abordaremos a Integração Numérica, e voltaremos a usar uma planilha eletrônica. Mas o processo também não será iterativo.\nNo capítulo 5 passaremos a abordar Sistemas Lineares e vamos voltar a usar uma planilha eletrônica. Nesse capítulo o processo será iterativo.\nEntão vamos começar com o primeiro método iterativo numérico.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Zeros de Funções</span>"
    ]
  },
  {
    "objectID": "index.html#método-da-bissecção",
    "href": "index.html#método-da-bissecção",
    "title": "Cálculo Numérico Modular",
    "section": "1.6 Método da Bissecção",
    "text": "1.6 Método da Bissecção\nEste método consiste em refinar intervalos que chamamos aqui de intervalos de bolzano. Cada iteração corta o intervalo pela metade, mas de forma que a propriedade da presença da raiz seja preservada. Nessa sequência de cortes, uma hora o tamanho do intervalo e consequentemente os candidatos à raiz será menor do que um valor ɛ previamente definido. Vamos começar apresentando o Teorema de Bolzano.\n\n\n\n\n\n\nTeorema de Bolzano\n\n\n\n\n\nSeja \\(f\\) uma função contínua num intervalo fechado \\([a,b]\\) talque \\(f(a)f(b)&lt;0\\). Então \\(f\\) possui uma raiz no intervalo \\([a,b]\\).\n\n\n\nO intervalo fechado significa que ele é delimitado pelas suas extremidades : \\(a\\) e \\(b\\). Consequentemente, o gráfico da função também tem extremidades. O teorema garante que se a função é contínua e as extremidades do gráfico estão em lados opostos do eixo x, então o gráfico cruza o eixo x em algum ponto do intervalo.\nSejam dados um intervalo inicial de Bolzano \\(I_{0}=[a_{0},b_{0}]\\) e uma precisão ɛ. O primeiro candidato à raiz é o seu ponto médio\n\\[x_{0}=\\frac{a_{0}+b_{0}}{2}\\] que divide o intervalo \\(I_{0}\\) em duas metades. Se o ponto médio não for a raíz então ela deve estar em uma das metades, conforme diz o Teorema. A metade que mantêm a propriedade de Bolzano, ou seja as extremidades do gráfico em lados opostos, será o novo intervalo de Bolzano \\(I_{1}\\), cujo tamanho é a metade do anterior.\nRepete-se esse procedimento até satisfazer os critérios de parada ou o ponto médio acertar a raíz. Os critérios de parada que usaremos são\n\\[|f(x_{i})|&lt;\\varepsilon\\] e \\[|x_{i+1}-x_{i}|&lt;\\varepsilon.\\]\nO segundo critério, passo menor que \\(\\varepsilon\\), pode ser trocado por: intervalo \\(\\left|I_{i+1}\\right|&lt;\\varepsilon\\). Lembrando que \\(x_{i}\\) é uma das extremidades do intervalo \\(I_{i+1}\\) e \\(x_{i+1}\\) é o seu ponto médio. Por isso o tamanho do intervalo \\(I_{i+1}\\) é exatamente o dobro do passo \\(|x_{i+1}-x_{i}|\\).\nNa Figura Figure 1.1 vemos uma ilustração do Método da Bissecção, que consiste em uma sequência de Intervalos de Bolzano cada vez menores mas sempre contendo a raiz da função f. O intervalo seguinte será sempre a metade do atual e o ponto de corte é o seu ponto médio. A estimativa para a raíz em cada intervalo é esse ponto médio.\nEsse método da Bissecção em formato de algoritmo pode ser visto abaixo. A sua implementação pode ser feita em uma planilha eletrônica. Visando favorecer a legibilidade de informações, porém, adotamos uma precisão específica, tomada aleatoriamente, de 3 casas decimais e escolher o subintervalo à esquerda do ponto médio para testar a condição de Bolzano. Uma alternativa para fazer o teste de Bolzano seria o subintervalo à direita do ponto médio.\n\n\n\n\n\n\n\nAlgoritmo da Bissecção\n\n\n\n\n\nDada uma função \\(f(x)\\) contínua, um valor minúsculo \\(\\varepsilon\\) e um intervalo de Bolzano inicial \\((a_{0},b_{0})\\), para localizar uma raíz nesse intervalo cortamos seguidamente esse intervalo pela metade da seguinte maneira\n\nO intervalo atual sendo \\((a_{i},b_{i})\\) chamamos de Ponta-Esquerda (PE) e Ponta-Direita (PD) as extremidades \\(a_{i}\\) e \\(b_{i}\\), respectivamente. Seja \\(x_{i}\\) o ponto médio do intervalo. Se o tamanho do intervalo e a distância de \\(f(x_{i})\\) ao zero forem menores do que \\(\\varepsilon\\), isto é \\(\\|\\mbox{PD-PE}\\|&lt;\\varepsilon\\) e \\(\\|f(x_{i})\\|&lt;\\varepsilon\\), então pare aqui e a raíz aproximada será \\(x_{i}\\).\nSe \\(f(x_{i})=0\\) então pare aqui e a raíz exata será \\(x_{i}\\). Caso contrário tome como o novo intervalo \\((a_{i+1},b_{i+1})\\) uma das metades do intervalo, ou seja \\([PE,x_{i}]\\) ou \\([x_{i} ,PD]\\), aquele que seja um intervalo de Bolzano. Volte ao passo 1.\n\n\n\n\n\n\n\n\n\n\nFigure 1.1: Sequência de Intervalos de Bolzano\n\n\n\nPara implementar esse algoritmo usaremos uma planilha eletrônica seguindo os seguintes passos.\n\nDada uma função \\(f(x)\\) contínua em \\([a,b]\\) talque \\(f(a)f(b)&lt;0\\).\n\nDeclaração das variáveis:\n\nk (índice de iteração)\nε (precisão de contas)\nPE (Ponta-Esquerda do Intervalo)\nPD (Ponta-Direita do Intervalo)\nx (Ponto de Corte)\nf(PE) (a imagem do PE)\nf(x) (a imagem do Ponto de Corte)\nTeste (Teste de Bolzano)\n∆ (Passo)\n\nEntrada de valores/fórmulas:\n\nk = 0 (índice 0 para valores iniciais)\n\\(ε = 10^3\\) (precisão adotada)\nPE = a\nPD = b\nx = (PE+PD)/2\nf(PE) (a imagem do PE)\nf(x) (a imagem do x)\nTeste = f(PE) f(x)\n\nRefinamento\n\nNovoPE = Se(Teste&lt;0, PE, x)\nNovoPD = Se(Teste&lt;=0, x, PD)\n∆ = \\(abs(x_{1}-x_{0})\\)\n\n\n\nTrês observações a fazer. Primeiro, a razão de incluir 0 no Teste do NovoPD é forçar que o novo intervalo seja [x,x], tendo assim comprimento zero quando o ponto de corte, x, é o próprio zero da função. Com isso o processo terminaria. Segundo, para o Passo ∆ usamos o comando \\(abs(x_{1}-x_{0})\\) que fornece o valor absoluto da diferença entre os primeiros pontos médios. Por essa razão ele só pode ser definido a partir da primeira iteração. Terceiro, na implementação em alguma planilha eletrônica, não deve ser colocado os valores de cada variável, mas os respectivos endereços na planilha.\nEm planilha eletrônica o cabeçalho terá o seguinte aspecto\n\n\n\nCabeçalho do Método da Bissecção\n\n\nAs colunas F e H, em cor azulada, são os critérios de parada que adotamos \\[\\begin{array}{ccc}\n\\left|f(x)\\right|&lt;\\varepsilon & , & \\Delta&lt;\\varepsilon\\end{array}\\] onde \\(\\Delta=\\left|x_{i+1}-x_{i}\\right|\\) medem os passos da melhora no processo de aproximação ao zero da função. Quanto menor o passo, mais perto estamos da raíz. Essas colunas azuladas devem ser monitoradas para decidir se prosseguimos ou paramos com as iterações.Vamos entender melhor apresentando um exemplo.\n\nExemplo 1. Método da Bissecção, ache o valor de \\(\\sqrt{15}\\) com precisão de 7 casas decimais corretas.\n\nResolução. Três passos iniciais precisam ser trilhados. O primeiro é definir a função a zerar. Várias funções têm $$ como raíz, mas a mais simples delas talvez seja \\[f(x)=x^{2}-15\\] que é a que vamos adotar. Em seguida, vamos definir o intervalo inicial de Bolzano. Como \\[\\underbrace{\\sqrt{9}}_{3}&lt;\\sqrt{15}&lt;\\underbrace{\\sqrt{16}}_{4}\\] vamos adotar \\(I_{0}=[3,4]\\). Por fim, como o enunciado pede 7 casas decimais corretas, portanto $^{-7}$, vamos trabalhar com 8 casas decimais, pensando que esta última casa decimal pode resultar de um arredondamento, portanto imprecisa. A primeira linha ficaria assim\n\n\n\nPrimeira linha do Método da Bissecção\n\n\nNa segunda linha faremos a 1ª iteração e começaremos com o processo de refinamento do Ponta Esquerda PE, na B4, e do Ponta Direita PD, na D4.\n\n\n\nRefinamento do Método da Bissecção\n\n\nAs células C4, E4, F4 e G4 serão cópias das C3, E3, F3 e G3, respectivamente.\n\n\n\nCópias da Linha anterior\n\n\nFinalmente completamos a linha 2 com o primeiro passo.\n\n\n\nLinha 2 do Método da Bissecção\n\n\nFeita a primeira iteração, as demais repetem o processo de refinamento. Assim copiamos a linha 2 para as linhas abaixo e prestar atenção nas colunas azuladas. Depois de 25 iterações obtemos o quadro da Figura abaixo\n\n\n\nMétodo da Bissecção\n\n\nObserve que \\[\\begin{array}{c}\n\\mbox{F}28\\,=\\,0,00000004\\,&lt;0,0000001=\\varepsilon\\\\\n\\mbox{H}28\\,=\\,0,00000001\\,&lt;0,0000001=\\varepsilon\n\\end{array}.\\]\nDevemos assim monitorar as colunas azuladas para que os 7 primeiros dígitos depois da vírgula sejam todos zeros. O resultado é o último ponto médio, portanto \\[x_{28}=\\boldsymbol{3,8729833}\\] lembrando que o último dígito, 5, pode ser resultado de arredondamento, portanto não é preciso.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Zeros de Funções</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "2  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "3  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  }
]