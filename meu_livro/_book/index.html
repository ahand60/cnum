<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Armando Handaya">
<meta name="dcterms.date" content="2024-11-25">

<title>Cálculo Numérico Modular</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./intro.html" rel="next">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./index.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Zeros de Funções</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Cálculo Numérico Modular</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Zeros de Funções</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Prefácio</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./summary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Summary</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#zeros-de-funções" id="toc-zeros-de-funções" class="nav-link active" data-scroll-target="#zeros-de-funções"><span class="header-section-number">1</span> Zeros de Funções</a>
  <ul class="collapse">
  <li><a href="#precisão" id="toc-precisão" class="nav-link" data-scroll-target="#precisão"><span class="header-section-number">1.1</span> Precisão</a></li>
  <li><a href="#chute-inicial" id="toc-chute-inicial" class="nav-link" data-scroll-target="#chute-inicial"><span class="header-section-number">1.2</span> Chute Inicial</a></li>
  <li><a href="#método-de-refinamento" id="toc-método-de-refinamento" class="nav-link" data-scroll-target="#método-de-refinamento"><span class="header-section-number">1.3</span> Método de Refinamento</a></li>
  <li><a href="#critérios-de-parada" id="toc-critérios-de-parada" class="nav-link" data-scroll-target="#critérios-de-parada"><span class="header-section-number">1.4</span> Critérios de Parada</a></li>
  <li><a href="#execução-do-processo" id="toc-execução-do-processo" class="nav-link" data-scroll-target="#execução-do-processo"><span class="header-section-number">1.5</span> Execução do Processo</a></li>
  <li><a href="#método-da-bissecção" id="toc-método-da-bissecção" class="nav-link" data-scroll-target="#método-da-bissecção"><span class="header-section-number">1.6</span> Método da Bissecção</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Cálculo Numérico Modular</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Armando Handaya </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 25, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="zeros-de-funções" class="level1 numbered" data-number="1">
<h1 class="numbered" data-number="1"><span class="header-section-number">1</span> Zeros de Funções</h1>
<p>Neste capítulo trataremos de métodos para resolver equações. E como toda equação pode ser escrita por</p>
<p><span class="math display">\[f(x)=0\]</span></p>
<p>este assunto também é dito Zeros de Funções. Trataremos aqui de métodos que resolve equações que satisfazem algumas poucas condições. Mas essa restrição não invalida o esforço do estudo pois é grande a variedade de equações que podem ser resolvidos pelos métodos apresentados. Começamos definindo o zero de uma função.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Zero/Raíz
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Seja <span class="math inline">\(f\)</span> uma função e <span class="math inline">\(r\in Dom(f)\)</span> um elemento no domínio de <span class="math inline">\(f\)</span>. Este é dito um zero ou raíz da função se e somente se <span class="math display">\[f(r)=0.\]</span></p>
</div>
</div>
</div>
<p>Alguns exemplos de zeros de funções podemos ver na tabela abaixo.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">função</th>
<th style="text-align: center;">zero</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(f_1(x)=x^2-5x+3\)</span></td>
<td style="text-align: center;">0,6972243623</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(f_2(x)=-x^3-4x+3\)</span></td>
<td style="text-align: center;">0,6735930582</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(f_3(x)=\sqrt{x}-5e^{-x}\)</span></td>
<td style="text-align: center;">1,43044508899</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(f_4(x)=e^x+x\)</span></td>
<td style="text-align: center;">-0,56714329040</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(f_5(x)=x lnx-1\)</span></td>
<td style="text-align: center;">1,76322283304</td>
</tr>
</tbody>
</table>
<p>A função quadrática <span class="math inline">\(f_{1}(x)\)</span> pode ser resolvida pela fórmula de Bháskara <span class="math display">\[x=\frac{-b\pm \sqrt{b^2-4ac}}{2a}\]</span></p>
<p>que fornece a resposta diretamente. A função cúbica <span class="math inline">\(f_{2}(x)\)</span> pode ser resolvida pela fórmula de Tartáglia, mas as demais funções dessa lista não possuem fórmula alguma. Então como calcular os raízes delas ? Até funções polinômiais de ordem maior que 4 não há fórmulas de resolução. Dessa forma como se podemos resolver uma equação como <span class="math display">\[x^5+2x^2-x=0  ?\]</span></p>
<p>Neste capítulo, vamos aprender a resolver essa e outras equações que não possuem fórmulas prontas de resolução.</p>
<p>Os métodos que aprenderemos aqui são chamados de Métodos Iterativos. Isso por conta das iterações ou rodadas que fazemos para melhorar (ou refinar) cada vez mais a raíz da equação. Raíz de uma equação é a solução do problema em questão.</p>
<p>Diferentemente do Método Direto ou Analítico que usa uma fórmula como a de Bháskara para resolver uma equação de 2º grau. Essa fórmula nos fornece as raízes diretamente.</p>
<p>Métodos Iterativos são úteis para resolver equações que não possuem fórmulas de resolução. E elas são, na verdade, a maioria. Para determinar a raiz da equação pelo método iterativo existem algumas etapas que devemos percorrer, a saber :</p>
<ol type="1">
<li><p>Definir a precisão de conta.</p></li>
<li><p>Dar um chute inicial.</p></li>
<li><p>Escolher um Método de Refinamento.</p></li>
<li><p>Escolher um ou mais Critérios de Parada.</p></li>
<li><p>Executar o processo até satisfazer todos os critérios de Parada adotados.</p></li>
</ol>
<p>As quatro primeiras etapas normalmente são fornecidas no enunciado da questão, embora isso não seja uma regra. Já a quinta etapa é a parte que o aluno precisa fazer. É nesta etapa que o aluno será avaliado.</p>
<section id="precisão" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="precisão"><span class="header-section-number">1.1</span> Precisão</h2>
<p>A precisão da conta é para definir a proximidade em relação à raiz. Suponhamos que a raiz seja <span class="math inline">\(r=3,135104\)</span>. Consideremos os seguintes números</p>
<p><span class="math display">\[\left\{\begin{matrix}
a_1 = 3,135199\\
a_2 = 3,135098
\end{matrix}\right.\]</span></p>
<p>cujas diferenças em módulo em relação a r são, respectivamente</p>
<p><span class="math display">\[\begin{array}{c}|a_{1}-r|=0,000095&lt;10^{-4}\\|a_{2}-r|=0,000006&lt;10^{-5}\end{array}.\]</span></p>
<p>Dizemos que a precisão de <span class="math inline">\(a_{1}\)</span> é de <span class="math inline">\(\varepsilon=10^{-4}\)</span> e a de <span class="math inline">\(a_{2}\)</span> é de <span class="math inline">\(\varepsilon=10^{-5}\)</span>, portanto <span class="math inline">\(a_{2}\)</span> é mais próxima à raiz e por isso é um resultado melhor. Entretanto, não confunda a precisão com o número de casas decimais corretas. Observe que <span class="math inline">\(a_{1}\)</span> tem as primeiras 4 casas decimais corretas ao passo que <span class="math inline">\(a_{2}\)</span> apenas 3, embora seja um resultado melhor</p>
<p><span class="math display">\[\begin{array}{c}a_{1}=3,\underline{1351}99\\a_{2}=3,\underline{135}098\end{array}.\]</span></p>
<p>Outra maneira de se referir à precisão é dizer que <span class="math inline">\(a_{1}\)</span> tem precisão de 4 casas decimais e <span class="math inline">\(a_{2}\)</span> tem a precisão de 5 casas decimais. Isso tem a ver com o número de zeros na diferença para o valor correto e não com o número de decimais corretas. Mas há casos em que o enunciado pede justamente isso: decimais corretas até a <span class="math inline">\(n\)</span>-ésima casa. Por isso deve-se sempre prestar atenção no enunciado do problema! Quando se pede isso, o exemplo acima nos dá uma ideia do que fazer : aumentar a precisão em algumas casas decimais. Nesse exemplo vimos que <span class="math inline">\(a_{2}\)</span> tem a precisão de 5 casas, pois, <span class="math inline">\(\varepsilon=10^{-5}\)</span>, mas acerta apenas as 3 primeiras casas decimais. Se o enunciado pedir 4 corretas, temos que trabalhar com uma precisão maior, talvez <span class="math inline">\(\varepsilon=10^{-6}\)</span>. Mas, dependendo do dígito da <span class="math inline">\(n\)</span>-ésima casa, muitas vezes a precisão de <span class="math inline">\(n\)</span> casas já é suficiente. Veja no exemplo acima onde <span class="math inline">\(a_{1}\)</span> tem precisão de 4 casas e acertando as 4 decimais iniciais. Em geral, uma precisão de <span class="math inline">\(n+1\)</span> casas já serve para acertar as <span class="math inline">\(n\)</span> decimais iniciais. Mas isso nem sempre acontece. Quando há a presença de zeros no valor exato, por exemplo, pode dar problemas. Vejamos um exemplo. Suponhamos que o valor correto seja <span class="math display">\[r=3,121002.\]</span> Com a precisão de 5 casas e obtemos os seguintes resultados <span class="math display">\[\begin{array}{c}a_{1}=3,\underline{12}0993\\a_{2}=3,\underline{1210}10\\a_{3}=3,\underline{12100}9\end{array}\]</span> Verifique que todos têm a mesma precisão de <span class="math inline">\(\varepsilon=10^{-5}\)</span> mas os números <span class="math inline">\(a_{1},a_{2},a_{3}\)</span> acertam, respectivamente, duas, quatro e cinco casas decimais. Uma observação a fazer aqui é a seguinte: quando se pede n decimais corretas, não significa qualquer decimais mas sempre as primeiras decimais a partir da vírgula.</p>
</section>
<section id="chute-inicial" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="chute-inicial"><span class="header-section-number">1.2</span> Chute Inicial</h2>
<p>Caso o valor inicial não seja fornecido, você mesmo deve fazer esse chute. Depois, é só rodar o programa e veja se ele converge para algum ponto fixo. Esse ponto fixo será a raiz do problema. Um bom chute inicial faz o processo convergir para algum lugar. Esse lugar que falamos é um valor cujo processo modifica muito pouco os seus dígitos, talvez só na décima primeira casa decimal. Por isso o chamamos de ponto fixo.</p>
<p>Mas, como podemos saber se o chute inicial que fizemos foi bom ou não ? Essa é uma boa pergunta. Normalmente se você começar por um ponto mais ou menos próximo à raiz, será um bom chute. Mas pode acontecer que o chute não seja tão perto da raiz, mesmo assim converge para um ponto fixo. Então não se preocupe muito com isso. Basta você rodar o programa e ver se converge. Se não convergir, tente outro chute e recomece o processo.</p>
</section>
<section id="método-de-refinamento" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="método-de-refinamento"><span class="header-section-number">1.3</span> Método de Refinamento</h2>
<p>A segunda etapa é escolher um método de refinamento. Esse método por vezes também é uma exigência do professor/examinador. Mas quando não é fornecido ou não é exigido, você pode escolher qualquer um dos métodos ensinados e aprendidos.</p>
</section>
<section id="critérios-de-parada" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="critérios-de-parada"><span class="header-section-number">1.4</span> Critérios de Parada</h2>
<p>Neste texto vamos usar dois critérios de parada, um para cada variável. Por que isso ? Lembramos que estamos trabalhando com duas variáveis, <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span>, a segunda dependente da primeira, ou seja <span class="math inline">\(y=f(x)\)</span>. Dizemos que <span class="math inline">\(y\)</span> é a imagem de <span class="math inline">\(x\)</span> e que <span class="math inline">\(x\)</span> é abscissa de <span class="math inline">\(y\)</span>. Também se diz de <span class="math inline">\(y\)</span> como ordenada de <span class="math inline">\(x\)</span> e <span class="math inline">\(x\)</span> como pré-imagem de <span class="math inline">\(y\)</span>. Lembrando que, uma raiz de <span class="math inline">\(f\)</span> é um valor <span class="math inline">\(x=r\)</span> tal que <span class="math inline">\(y=f(r)=0\)</span>. Assim queremos achar um valor da variável <span class="math inline">\(x\)</span> determinado pelo valor 0 da outra variável: <span class="math inline">\(y\)</span>. Quem pode-me garantir que um valor próximo à raiz tem imagem próxima de zero ? Veja por exemplo a função</p>
<p><span class="math display">\[f(x)=5000x^2-300\]</span></p>
<p>cuja raíz positiva é <span class="math inline">\(r=0,24495\)</span>. O valor <span class="math inline">\(a=0,244\)</span> é bastante próxima à raiz com precisão de <span class="math inline">\(0,00095&lt;\varepsilon=10^{-3}\)</span> mas a imagem dele é longe de zero, pois <span class="math inline">\(f(a)=-2,32\)</span> . Na verdade, qualquer função cujo gráfico é quase vertical na raiz vai dar esse problema.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Casivertical.png" class="img-fluid figure-img"></p>
<figcaption>Gráfico da função <span class="math inline">\(f(x)\)</span></figcaption>
</figure>
</div>
<p>Dessa forma, vamos adotar dois critérios de parada. Para a variável x devemos garantir que</p>
<p><span class="math display">\[|x-r|&lt;\varepsilon\]</span></p>
<p>e para a variável <span class="math inline">\(y=f(x)\)</span> vamos adotar o critério</p>
<p><span class="math display">\[|f(x)|&lt;\varepsilon\]</span> e usaremos a mesma precisão para ambos os critérios. Mas observe que há um grande problema no primeiro critério de parada, pois não sabemos o valor exato de <span class="math inline">\(r\)</span>. Justamente esse valor de <span class="math inline">\(r\)</span> que estamos procurando. Portanto precisamos trocá-lo por outro critério tangível. Há duas formas de fazer isso. O primeiro deles é calcular a melhora dos passos da sequência de iterações (também chamado de erro absoluto). <span class="math display">\[|x_{i}-x_{i+1}|&lt;\varepsilon\]</span></p>
<p>A segunda maneira é calcular a “porcentagem” de melhora desses passos ou mais precisamente a taxa de melhora dos passos (também chamado de erro relativo), dada por</p>
<p><span class="math display">\[\left|\frac{x_{i}-x_{i+1}}{x_{i+1}}\right|&lt;\varepsilon\]</span></p>
<p>Essa segunda fórmula é mais sensível a erros, pois em nenhum momento a sequência de iterações pode atingir o valor zero. Pois senão estaríamos dividindo por zero. Aliás, essa também é a razão porque se coloca <span class="math inline">\(x_{i+1}\)</span> no denominador, e não <span class="math inline">\(x_{i}\)</span>, pois na maioria das vezes o valor inicial que adotamos é o zero. Se assim for, o processo já começa com problema.</p>
<p>Diante do exposto vamos adotar o critério de melhora dos passos para garantir a aproximação da abscissa x à raiz em questão.</p>
<p>Um terceiro critério de parada seria o número máximo de iterações. Existem casos em que o processo de refinamento não converge para nenhum lugar. Nesses casos nenhum dos critérios anteriores serão satisfeitos, mas o processo precisa parar de alguma forma. Para isso pode-se adotar o número máxima de iterações como outro critério de parada. Isso é necessário quando o processo é implementado em um sistema automático, como em computador. Quando o processo é executado manualmente o número máximo de iterações não deve ser muito alto, talvez no máximo uma dúzia de iterações ou próximo disso. Hoje em dia com o recurso do computador esse número máximo pode ser um milhão ou mais. Mas neste caso o problema passa a ser o esforço humano. Acredito que ninguém vai fazer um milhão de rodadas a não ser que saiba automatizar esse processo. Para isso você deve saber e usar uma linguagem de programação, o que complica mais o aprendizado. Mesmo assim, acredito que se um processo atingir um milhão de rodadas … muito provavelmente ele não vai convergir a lugar nenhum. Então porque raios devemos executar tantas rodadas ? Como disse antes, se você rodar e depois de umas cinquenta rodadas, ou até menos, ele não atinge um ponto fixo .. você deve começar a desconfiar que o processo não converge. Neste caso, descarte tudo e comece novamente com outro chute inicial. Simples assim. Por este motivo também que não vamos adotar esse terceiro critério de parada.</p>
</section>
<section id="execução-do-processo" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="execução-do-processo"><span class="header-section-number">1.5</span> Execução do Processo</h2>
<p>A fase de execução do processo é aquela que o aluno precisa mostrar na prova/exame. Neste texto a execução do processo não será feita manualmente e nem tampouco automaticamente. Vamos implementar sim em um computador mas o processo não será executado automaticamente, mas sim iteração por iteração. Por isso mesmo não vamos precisar impor o número máximo de iterações como um critério de parada. Vamos avaliar a continuidade do processo ou não a cada nova iteração.</p>
<p>A execução do processo será feita no computador usando softwares específicos. No caso de zeros de funções, assunto deste capítulo, vamos usar uma planilha eletrônica tais como Excel, Calc, Google Planilhas ou Geogebra. Cada iteração corresponde a uma linha da planilha.</p>
<p>No capítulo 2, quando falamos de ajuste de curvas, vamos usar o Matlab, Scilab, Octave ou Geogebra. Mas nesse capítulo o processo não será iterativo, senão analítico. Uma única iteração basta para resolver o problema.</p>
<p>No capítulo 3, falamos de Interpolação Polinomial. Nele vamos usar o software Geogebra e o processo também não será iterativo.</p>
<p>No capítulo 4. abordaremos a Integração Numérica, e voltaremos a usar uma planilha eletrônica. Mas o processo também não será iterativo.</p>
<p>No capítulo 5 passaremos a abordar Sistemas Lineares e vamos voltar a usar uma planilha eletrônica. Nesse capítulo o processo será iterativo.</p>
<p>Então vamos começar com o primeiro método iterativo numérico.</p>
</section>
<section id="método-da-bissecção" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="método-da-bissecção"><span class="header-section-number">1.6</span> Método da Bissecção</h2>
<p>Este método consiste em refinar intervalos que chamamos aqui de intervalos de bolzano. Cada iteração corta o intervalo pela metade, mas de forma que a propriedade da presença da raiz seja preservada. Nessa sequência de cortes, uma hora o tamanho do intervalo e consequentemente os candidatos à raiz será menor do que um valor ɛ previamente definido. Vamos começar apresentando o Teorema de Bolzano.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Teorema de Bolzano
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Seja <span class="math inline">\(f\)</span> uma função contínua num intervalo fechado <span class="math inline">\([a,b]\)</span> talque <span class="math inline">\(f(a)f(b)&lt;0\)</span>. Então <span class="math inline">\(f\)</span> possui uma raiz no intervalo <span class="math inline">\([a,b]\)</span>.</p>
</div>
</div>
</div>
<p>O intervalo fechado significa que ele é delimitado pelas suas extremidades : <span class="math inline">\(a\)</span> e <span class="math inline">\(b\)</span>. Consequentemente, o gráfico da função também tem extremidades. O teorema garante que se a função é contínua e as extremidades do gráfico estão em lados opostos do eixo x, então o gráfico cruza o eixo x em algum ponto do intervalo.</p>
<p>Sejam dados um intervalo inicial de Bolzano <span class="math inline">\(I_{0}=[a_{0},b_{0}]\)</span> e uma precisão ɛ. O primeiro candidato à raiz é o seu ponto médio</p>
<p><span class="math display">\[x_{0}=\frac{a_{0}+b_{0}}{2}\]</span> que divide o intervalo <span class="math inline">\(I_{0}\)</span> em duas metades. Se o ponto médio não for a raíz então ela deve estar em uma das metades, conforme diz o Teorema. A metade que mantêm a propriedade de Bolzano, ou seja as extremidades do gráfico em lados opostos, será o novo intervalo de Bolzano <span class="math inline">\(I_{1}\)</span>, cujo tamanho é a metade do anterior.</p>
<p>Repete-se esse procedimento até satisfazer os critérios de parada ou o ponto médio acertar a raíz. Os critérios de parada que usaremos são</p>
<p><span class="math display">\[|f(x_{i})|&lt;\varepsilon\]</span> e <span class="math display">\[|x_{i+1}-x_{i}|&lt;\varepsilon.\]</span></p>
<p>O segundo critério, passo menor que <span class="math inline">\(\varepsilon\)</span>, pode ser trocado por: intervalo <span class="math inline">\(\left|I_{i+1}\right|&lt;\varepsilon\)</span>. Lembrando que <span class="math inline">\(x_{i}\)</span> é uma das extremidades do intervalo <span class="math inline">\(I_{i+1}\)</span> e <span class="math inline">\(x_{i+1}\)</span> é o seu ponto médio. Por isso o tamanho do intervalo <span class="math inline">\(I_{i+1}\)</span> é exatamente o dobro do passo <span class="math inline">\(|x_{i+1}-x_{i}|\)</span>.</p>
<p>Na Figura <a href="#fig-SeqInt" class="quarto-xref">Figure&nbsp;<span class="quarto-unresolved-ref">fig-SeqInt</span></a> vemos uma ilustração do Método da Bissecção, que consiste em uma sequência de Intervalos de Bolzano cada vez menores mas sempre contendo a raiz da função f.&nbsp;O intervalo seguinte será sempre a metade do atual e o ponto de corte é o seu ponto médio. A estimativa para a raíz em cada intervalo é esse ponto médio.</p>
<p>Esse método da Bissecção em formato de algoritmo pode ser visto abaixo. A sua implementação pode ser feita em uma planilha eletrônica. Visando favorecer a legibilidade de informações, porém, adotamos uma precisão específica, tomada aleatoriamente, de 3 casas decimais e escolher o subintervalo à esquerda do ponto médio para testar a condição de Bolzano. Uma alternativa para fazer o teste de Bolzano seria o subintervalo à direita do ponto médio.</p>
<hr>
<div id="AlgBiss" class="callout callout-style-default callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Algoritmo da Bissecção
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Dada uma função <span class="math inline">\(f(x)\)</span> contínua, um valor minúsculo <span class="math inline">\(\varepsilon\)</span> e um intervalo de Bolzano inicial <span class="math inline">\((a_{0},b_{0})\)</span>, para localizar uma raíz nesse intervalo cortamos seguidamente esse intervalo pela metade da seguinte maneira</p>
<ol type="1">
<li><p>O intervalo atual sendo <span class="math inline">\((a_{i},b_{i})\)</span> chamamos de Ponta-Esquerda (PE) e Ponta-Direita (PD) as extremidades <span class="math inline">\(a_{i}\)</span> e <span class="math inline">\(b_{i}\)</span>, respectivamente. Seja <span class="math inline">\(x_{i}\)</span> o ponto médio do intervalo. Se o tamanho do intervalo e a distância de <span class="math inline">\(f(x_{i})\)</span> ao zero forem menores do que <span class="math inline">\(\varepsilon\)</span>, isto é <span class="math inline">\(\|\mbox{PD-PE}\|&lt;\varepsilon\)</span> e <span class="math inline">\(\|f(x_{i})\|&lt;\varepsilon\)</span>, então pare aqui e a raíz aproximada será <span class="math inline">\(x_{i}\)</span>.</p></li>
<li><p>Se <span class="math inline">\(f(x_{i})=0\)</span> então pare aqui e a raíz exata será <span class="math inline">\(x_{i}\)</span>. Caso contrário tome como o novo intervalo <span class="math inline">\((a_{i+1},b_{i+1})\)</span> uma das metades do intervalo, ou seja <span class="math inline">\([PE,x_{i}]\)</span> ou <span class="math inline">\([x_{i} ,PD]\)</span>, aquele que seja um intervalo de Bolzano. Volte ao passo 1.</p></li>
</ol>
</div>
</div>
</div>
<div id="fig-SeqInt" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-SeqInt-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="IntervalosBolzano.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-SeqInt-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1.1: Sequência de Intervalos de Bolzano
</figcaption>
</figure>
</div>
<p>Para implementar esse algoritmo usaremos uma planilha eletrônica seguindo os seguintes passos.</p>
<hr>
<p>Dada uma função <span class="math inline">\(f(x)\)</span> contínua em <span class="math inline">\([a,b]\)</span> talque <span class="math inline">\(f(a)f(b)&lt;0\)</span>.</p>
<ol type="1">
<li><strong>Declaração das variáveis</strong>:
<ol type="a">
<li>k (índice de iteração)</li>
<li>ε (precisão de contas)</li>
<li>PE (Ponta-Esquerda do Intervalo)</li>
<li>PD (Ponta-Direita do Intervalo)</li>
<li>x (Ponto de Corte)</li>
<li>f(PE) (a imagem do PE)</li>
<li>f(x) (a imagem do Ponto de Corte)</li>
<li>Teste (Teste de Bolzano)</li>
<li>∆ (Passo)</li>
</ol></li>
<li><strong>Entrada de valores/fórmulas</strong>:
<ol type="a">
<li>k = 0 (índice 0 para valores iniciais)</li>
<li><span class="math inline">\(ε = 10^3\)</span> (precisão adotada)</li>
<li>PE = a</li>
<li>PD = b</li>
<li>x = (PE+PD)/2</li>
<li>f(PE) (a imagem do PE)</li>
<li>f(x) (a imagem do x)</li>
<li>Teste = f(PE) f(x)</li>
</ol></li>
<li><strong>Refinamento</strong>
<ol type="a">
<li>NovoPE = Se(Teste&lt;0, PE, x)</li>
<li>NovoPD = Se(Teste&lt;=0, x, PD)</li>
<li>∆ = <span class="math inline">\(abs(x_{1}-x_{0})\)</span></li>
</ol></li>
</ol>
<hr>
<p>Três observações a fazer. Primeiro, a razão de incluir 0 no Teste do NovoPD é forçar que o novo intervalo seja [x,x], tendo assim comprimento zero quando o ponto de corte, x, é o próprio zero da função. Com isso o processo terminaria. Segundo, para o Passo ∆ usamos o comando <span class="math inline">\(abs(x_{1}-x_{0})\)</span> que fornece o valor absoluto da diferença entre os primeiros pontos médios. Por essa razão ele só pode ser definido a partir da primeira iteração. Terceiro, na implementação em alguma planilha eletrônica, não deve ser colocado os valores de cada variável, mas os respectivos endereços na planilha.</p>
<p>Em planilha eletrônica o cabeçalho terá o seguinte aspecto</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="CabBis.png" class="img-fluid figure-img"></p>
<figcaption>Cabeçalho do Método da Bissecção</figcaption>
</figure>
</div>
<p>As colunas F e H, em cor azulada, são os critérios de parada que adotamos <span class="math display">\[\begin{array}{ccc}
\left|f(x)\right|&lt;\varepsilon &amp; , &amp; \Delta&lt;\varepsilon\end{array}\]</span> onde <span class="math inline">\(\Delta=\left|x_{i+1}-x_{i}\right|\)</span> medem os passos da melhora no processo de aproximação ao zero da função. Quanto menor o passo, mais perto estamos da raíz. Essas colunas azuladas devem ser monitoradas para decidir se prosseguimos ou paramos com as iterações.Vamos entender melhor apresentando um exemplo.</p>
<div style="background-color: #C0ffC0; border: 1px solid #ccc; padding: 15px; border-radius: 5px; margin: 20px 0;">
<p><strong>Exemplo 1</strong>. Método da Bissecção, ache o valor de <span class="math inline">\(\sqrt{15}\)</span> com precisão de 7 casas decimais corretas.</p>
</div>
<p><strong>Resolução</strong>. Três passos iniciais precisam ser trilhados. O primeiro é definir a função a zerar. Várias funções têm $$ como raíz, mas a mais simples delas talvez seja <span class="math display">\[f(x)=x^{2}-15\]</span> que é a que vamos adotar. Em seguida, vamos definir o intervalo inicial de Bolzano. Como <span class="math display">\[\underbrace{\sqrt{9}}_{3}&lt;\sqrt{15}&lt;\underbrace{\sqrt{16}}_{4}\]</span> vamos adotar <span class="math inline">\(I_{0}=[3,4]\)</span>. Por fim, como o enunciado pede 7 casas decimais corretas, portanto $^{-7}$, vamos trabalhar com 8 casas decimais, pensando que esta última casa decimal pode resultar de um arredondamento, portanto imprecisa. A primeira linha ficaria assim</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="CabBis1.png" class="img-fluid figure-img"></p>
<figcaption>Primeira linha do Método da Bissecção</figcaption>
</figure>
</div>
<p>Na segunda linha faremos a 1ª iteração e começaremos com o processo de refinamento do Ponta Esquerda PE, na B4, e do Ponta Direita PD, na D4.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="CabBis2.png" class="img-fluid figure-img"></p>
<figcaption>Refinamento do Método da Bissecção</figcaption>
</figure>
</div>
<p>As células C4, E4, F4 e G4 serão cópias das C3, E3, F3 e G3, respectivamente.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="CabBis2a.png" class="img-fluid figure-img"></p>
<figcaption>Cópias da Linha anterior</figcaption>
</figure>
</div>
<p>Finalmente completamos a linha 2 com o primeiro passo.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="CabBis2b.png" class="img-fluid figure-img"></p>
<figcaption>Linha 2 do Método da Bissecção</figcaption>
</figure>
</div>
<p>Feita a primeira iteração, as demais repetem o processo de refinamento. Assim copiamos a linha 2 para as linhas abaixo e prestar atenção nas colunas azuladas. Depois de 25 iterações obtemos o quadro da Figura abaixo</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="CabBis3.png" class="img-fluid figure-img"></p>
<figcaption>Método da Bissecção</figcaption>
</figure>
</div>
<p>Observe que <span class="math display">\[\begin{array}{c}
\mbox{F}28\,=\,0,00000004\,&lt;0,0000001=\varepsilon\\
\mbox{H}28\,=\,0,00000001\,&lt;0,0000001=\varepsilon
\end{array}.\]</span></p>
<p>Devemos assim monitorar as colunas azuladas para que os 7 primeiros dígitos depois da vírgula sejam todos zeros. O resultado é o último ponto médio, portanto <span class="math display">\[x_{28}=\boldsymbol{3,8729833}\]</span> lembrando que o último dígito, 5, pode ser resultado de arredondamento, portanto não é preciso.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
  </div>
  <div class="nav-page nav-page-next">
      <a href="./intro.html" class="pagination-link" aria-label="Prefácio">
        <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Prefácio</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>